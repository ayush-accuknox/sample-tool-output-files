{
    "results": [
        {
            "type": "containers",
            "id": "CVE-2020-36782",
            "similarityId": "CVE-2020-36782",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: imx-lpi2c: fix reference leak when pm_runtime_get_sync fails\n\nThe PM reference count is not expected to be incremented on\nreturn in lpi2c_imx_master_enable.\n\nHowever, pm_runtime_get_sync will increment the PM reference\ncount even failed. Forgetting to putting operation will result\nin a reference leak here.\n\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.",
            "data": {
                "packageName": "linux-libc-dev",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2020-36782",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2020-36782",
            "similarityId": "CVE-2020-36782",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: imx-lpi2c: fix reference leak when pm_runtime_get_sync fails\n\nThe PM reference count is not expected to be incremented on\nreturn in lpi2c_imx_master_enable.\n\nHowever, pm_runtime_get_sync will increment the PM reference\ncount even failed. Forgetting to putting operation will result\nin a reference leak here.\n\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.",
            "data": {
                "packageName": "linux",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2020-36782",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2020-36783",
            "similarityId": "CVE-2020-36783",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: img-scb: fix reference leak when pm_runtime_get_sync fails\n\nThe PM reference count is not expected to be incremented on\nreturn in functions img_i2c_xfer and img_i2c_init.\n\nHowever, pm_runtime_get_sync will increment the PM reference\ncount even failed. Forgetting to putting operation will result\nin a reference leak here.\n\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.",
            "data": {
                "packageName": "linux-libc-dev",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2020-36783",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2020-36783",
            "similarityId": "CVE-2020-36783",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: img-scb: fix reference leak when pm_runtime_get_sync fails\n\nThe PM reference count is not expected to be incremented on\nreturn in functions img_i2c_xfer and img_i2c_init.\n\nHowever, pm_runtime_get_sync will increment the PM reference\ncount even failed. Forgetting to putting operation will result\nin a reference leak here.\n\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.",
            "data": {
                "packageName": "linux",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2020-36783",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2020-36784",
            "similarityId": "CVE-2020-36784",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: cadence: fix reference leak when pm_runtime_get_sync fails\n\nThe PM reference count is not expected to be incremented on\nreturn in functions cdns_i2c_master_xfer and cdns_reg_slave.\n\nHowever, pm_runtime_get_sync will increment pm usage counter\neven failed. Forgetting to putting operation will result in a\nreference leak here.\n\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.",
            "data": {
                "packageName": "linux-libc-dev",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2020-36784",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2020-36784",
            "similarityId": "CVE-2020-36784",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ni2c: cadence: fix reference leak when pm_runtime_get_sync fails\n\nThe PM reference count is not expected to be incremented on\nreturn in functions cdns_i2c_master_xfer and cdns_reg_slave.\n\nHowever, pm_runtime_get_sync will increment pm usage counter\neven failed. Forgetting to putting operation will result in a\nreference leak here.\n\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.",
            "data": {
                "packageName": "linux",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2020-36784",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2021-3487",
            "similarityId": "CVE-2021-3487",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "Rejected reason: Non Security Issue. See the binutils security policy for more details, https://sourceware.org/cgit/binutils-gdb/tree/binutils/SECURITY.txt",
            "data": {
                "packageName": "libbinutils",
                "packageVersion": "2.31.1-16",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2021-3487",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2021-3487",
            "similarityId": "CVE-2021-3487",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "Rejected reason: Non Security Issue. See the binutils security policy for more details, https://sourceware.org/cgit/binutils-gdb/tree/binutils/SECURITY.txt",
            "data": {
                "packageName": "binutils-common",
                "packageVersion": "2.31.1-16",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2021-3487",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2021-3487",
            "similarityId": "CVE-2021-3487",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "Rejected reason: Non Security Issue. See the binutils security policy for more details, https://sourceware.org/cgit/binutils-gdb/tree/binutils/SECURITY.txt",
            "data": {
                "packageName": "binutils",
                "packageVersion": "2.31.1-16",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2021-3487",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2021-46981",
            "similarityId": "CVE-2021-46981",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnbd: Fix NULL pointer in flush_workqueue\n\nOpen /dev/nbdX first, the config_refs will be 1 and\nthe pointers in nbd_device are still null. Disconnect\n/dev/nbdX, then reference a null recv_workq. The\nprotection by config_refs in nbd_genl_disconnect is useless.\n\n[  656.366194] BUG: kernel NULL pointer dereference, address: 0000000000000020\n[  656.368943] #PF: supervisor write access in kernel mode\n[  656.369844] #PF: error_code(0x0002) - not-present page\n[  656.370717] PGD 10cc87067 P4D 10cc87067 PUD 1074b4067 PMD 0\n[  656.371693] Oops: 0002 [#1] SMP\n[  656.372242] CPU: 5 PID: 7977 Comm: nbd-client Not tainted 5.11.0-rc5-00040-g76c057c84d28 #1\n[  656.373661] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20190727_073836-buildvm-ppc64le-16.ppc.fedoraproject.org-3.fc31 04/01/2014\n[  656.375904] RIP: 0010:mutex_lock+0x29/0x60\n[  656.376627] Code: 00 0f 1f 44 00 00 55 48 89 fd 48 83 05 6f d7 fe 08 01 e8 7a c3 ff ff 48 83 05 6a d7 fe 08 01 31 c0 65 48 8b 14 25 00 6d 01 00 <f0> 48 0f b1 55 d\n[  656.378934] RSP: 0018:ffffc900005eb9b0 EFLAGS: 00010246\n[  656.379350] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\n[  656.379915] RDX: ffff888104cf2600 RSI: ffffffffaae8f452 RDI: 0000000000000020\n[  656.380473] RBP: 0000000000000020 R08: 0000000000000000 R09: ffff88813bd6b318\n[  656.381039] R10: 00000000000000c7 R11: fefefefefefefeff R12: ffff888102710b40\n[  656.381599] R13: ffffc900005eb9e0 R14: ffffffffb2930680 R15: ffff88810770ef00\n[  656.382166] FS:  00007fdf117ebb40(0000) GS:ffff88813bd40000(0000) knlGS:0000000000000000\n[  656.382806] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  656.383261] CR2: 0000000000000020 CR3: 0000000100c84000 CR4: 00000000000006e0\n[  656.383819] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  656.384370] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  656.384927] Call Trace:\n[  656.385111]  flush_workqueue+0x92/0x6c0\n[  656.385395]  nbd_disconnect_and_put+0x81/0xd0\n[  656.385716]  nbd_genl_disconnect+0x125/0x2a0\n[  656.386034]  genl_family_rcv_msg_doit.isra.0+0x102/0x1b0\n[  656.386422]  genl_rcv_msg+0xfc/0x2b0\n[  656.386685]  ? nbd_ioctl+0x490/0x490\n[  656.386954]  ? genl_family_rcv_msg_doit.isra.0+0x1b0/0x1b0\n[  656.387354]  netlink_rcv_skb+0x62/0x180\n[  656.387638]  genl_rcv+0x34/0x60\n[  656.387874]  netlink_unicast+0x26d/0x590\n[  656.388162]  netlink_sendmsg+0x398/0x6c0\n[  656.388451]  ? netlink_rcv_skb+0x180/0x180\n[  656.388750]  ____sys_sendmsg+0x1da/0x320\n[  656.389038]  ? ____sys_recvmsg+0x130/0x220\n[  656.389334]  ___sys_sendmsg+0x8e/0xf0\n[  656.389605]  ? ___sys_recvmsg+0xa2/0xf0\n[  656.389889]  ? handle_mm_fault+0x1671/0x21d0\n[  656.390201]  __sys_sendmsg+0x6d/0xe0\n[  656.390464]  __x64_sys_sendmsg+0x23/0x30\n[  656.390751]  do_syscall_64+0x45/0x70\n[  656.391017]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nTo fix it, just add if (nbd->recv_workq) to nbd_disconnect_and_put().",
            "data": {
                "packageName": "linux",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2021-46981",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2021-46981",
            "similarityId": "CVE-2021-46981",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnbd: Fix NULL pointer in flush_workqueue\n\nOpen /dev/nbdX first, the config_refs will be 1 and\nthe pointers in nbd_device are still null. Disconnect\n/dev/nbdX, then reference a null recv_workq. The\nprotection by config_refs in nbd_genl_disconnect is useless.\n\n[  656.366194] BUG: kernel NULL pointer dereference, address: 0000000000000020\n[  656.368943] #PF: supervisor write access in kernel mode\n[  656.369844] #PF: error_code(0x0002) - not-present page\n[  656.370717] PGD 10cc87067 P4D 10cc87067 PUD 1074b4067 PMD 0\n[  656.371693] Oops: 0002 [#1] SMP\n[  656.372242] CPU: 5 PID: 7977 Comm: nbd-client Not tainted 5.11.0-rc5-00040-g76c057c84d28 #1\n[  656.373661] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS ?-20190727_073836-buildvm-ppc64le-16.ppc.fedoraproject.org-3.fc31 04/01/2014\n[  656.375904] RIP: 0010:mutex_lock+0x29/0x60\n[  656.376627] Code: 00 0f 1f 44 00 00 55 48 89 fd 48 83 05 6f d7 fe 08 01 e8 7a c3 ff ff 48 83 05 6a d7 fe 08 01 31 c0 65 48 8b 14 25 00 6d 01 00 <f0> 48 0f b1 55 d\n[  656.378934] RSP: 0018:ffffc900005eb9b0 EFLAGS: 00010246\n[  656.379350] RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\n[  656.379915] RDX: ffff888104cf2600 RSI: ffffffffaae8f452 RDI: 0000000000000020\n[  656.380473] RBP: 0000000000000020 R08: 0000000000000000 R09: ffff88813bd6b318\n[  656.381039] R10: 00000000000000c7 R11: fefefefefefefeff R12: ffff888102710b40\n[  656.381599] R13: ffffc900005eb9e0 R14: ffffffffb2930680 R15: ffff88810770ef00\n[  656.382166] FS:  00007fdf117ebb40(0000) GS:ffff88813bd40000(0000) knlGS:0000000000000000\n[  656.382806] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  656.383261] CR2: 0000000000000020 CR3: 0000000100c84000 CR4: 00000000000006e0\n[  656.383819] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n[  656.384370] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n[  656.384927] Call Trace:\n[  656.385111]  flush_workqueue+0x92/0x6c0\n[  656.385395]  nbd_disconnect_and_put+0x81/0xd0\n[  656.385716]  nbd_genl_disconnect+0x125/0x2a0\n[  656.386034]  genl_family_rcv_msg_doit.isra.0+0x102/0x1b0\n[  656.386422]  genl_rcv_msg+0xfc/0x2b0\n[  656.386685]  ? nbd_ioctl+0x490/0x490\n[  656.386954]  ? genl_family_rcv_msg_doit.isra.0+0x1b0/0x1b0\n[  656.387354]  netlink_rcv_skb+0x62/0x180\n[  656.387638]  genl_rcv+0x34/0x60\n[  656.387874]  netlink_unicast+0x26d/0x590\n[  656.388162]  netlink_sendmsg+0x398/0x6c0\n[  656.388451]  ? netlink_rcv_skb+0x180/0x180\n[  656.388750]  ____sys_sendmsg+0x1da/0x320\n[  656.389038]  ? ____sys_recvmsg+0x130/0x220\n[  656.389334]  ___sys_sendmsg+0x8e/0xf0\n[  656.389605]  ? ___sys_recvmsg+0xa2/0xf0\n[  656.389889]  ? handle_mm_fault+0x1671/0x21d0\n[  656.390201]  __sys_sendmsg+0x6d/0xe0\n[  656.390464]  __x64_sys_sendmsg+0x23/0x30\n[  656.390751]  do_syscall_64+0x45/0x70\n[  656.391017]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nTo fix it, just add if (nbd->recv_workq) to nbd_disconnect_and_put().",
            "data": {
                "packageName": "linux-libc-dev",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2021-46981",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2021-46984",
            "similarityId": "CVE-2021-46984",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkyber: fix out of bounds access when preempted\n\n__blk_mq_sched_bio_merge() gets the ctx and hctx for the current CPU and\npasses the hctx to ->bio_merge(). kyber_bio_merge() then gets the ctx\nfor the current CPU again and uses that to get the corresponding Kyber\ncontext in the passed hctx. However, the thread may be preempted between\nthe two calls to blk_mq_get_ctx(), and the ctx returned the second time\nmay no longer correspond to the passed hctx. This \"works\" accidentally\nmost of the time, but it can cause us to read garbage if the second ctx\ncame from an hctx with more ctx's than the first one (i.e., if\nctx->index_hw[hctx->type] > hctx->nr_ctx).\n\nThis manifested as this UBSAN array index out of bounds error reported\nby Jakub:\n\nUBSAN: array-index-out-of-bounds in ../kernel/locking/qspinlock.c:130:9\nindex 13106 is out of range for type 'long unsigned int [128]'\nCall Trace:\n dump_stack+0xa4/0xe5\n ubsan_epilogue+0x5/0x40\n __ubsan_handle_out_of_bounds.cold.13+0x2a/0x34\n queued_spin_lock_slowpath+0x476/0x480\n do_raw_spin_lock+0x1c2/0x1d0\n kyber_bio_merge+0x112/0x180\n blk_mq_submit_bio+0x1f5/0x1100\n submit_bio_noacct+0x7b0/0x870\n submit_bio+0xc2/0x3a0\n btrfs_map_bio+0x4f0/0x9d0\n btrfs_submit_data_bio+0x24e/0x310\n submit_one_bio+0x7f/0xb0\n submit_extent_page+0xc4/0x440\n __extent_writepage_io+0x2b8/0x5e0\n __extent_writepage+0x28d/0x6e0\n extent_write_cache_pages+0x4d7/0x7a0\n extent_writepages+0xa2/0x110\n do_writepages+0x8f/0x180\n __writeback_single_inode+0x99/0x7f0\n writeback_sb_inodes+0x34e/0x790\n __writeback_inodes_wb+0x9e/0x120\n wb_writeback+0x4d2/0x660\n wb_workfn+0x64d/0xa10\n process_one_work+0x53a/0xa80\n worker_thread+0x69/0x5b0\n kthread+0x20b/0x240\n ret_from_fork+0x1f/0x30\n\nOnly Kyber uses the hctx, so fix it by passing the request_queue to\n->bio_merge() instead. BFQ and mq-deadline just use that, and Kyber can\nmap the queues itself to avoid the mismatch.",
            "data": {
                "packageName": "linux-libc-dev",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2021-46984",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2021-46984",
            "similarityId": "CVE-2021-46984",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nkyber: fix out of bounds access when preempted\n\n__blk_mq_sched_bio_merge() gets the ctx and hctx for the current CPU and\npasses the hctx to ->bio_merge(). kyber_bio_merge() then gets the ctx\nfor the current CPU again and uses that to get the corresponding Kyber\ncontext in the passed hctx. However, the thread may be preempted between\nthe two calls to blk_mq_get_ctx(), and the ctx returned the second time\nmay no longer correspond to the passed hctx. This \"works\" accidentally\nmost of the time, but it can cause us to read garbage if the second ctx\ncame from an hctx with more ctx's than the first one (i.e., if\nctx->index_hw[hctx->type] > hctx->nr_ctx).\n\nThis manifested as this UBSAN array index out of bounds error reported\nby Jakub:\n\nUBSAN: array-index-out-of-bounds in ../kernel/locking/qspinlock.c:130:9\nindex 13106 is out of range for type 'long unsigned int [128]'\nCall Trace:\n dump_stack+0xa4/0xe5\n ubsan_epilogue+0x5/0x40\n __ubsan_handle_out_of_bounds.cold.13+0x2a/0x34\n queued_spin_lock_slowpath+0x476/0x480\n do_raw_spin_lock+0x1c2/0x1d0\n kyber_bio_merge+0x112/0x180\n blk_mq_submit_bio+0x1f5/0x1100\n submit_bio_noacct+0x7b0/0x870\n submit_bio+0xc2/0x3a0\n btrfs_map_bio+0x4f0/0x9d0\n btrfs_submit_data_bio+0x24e/0x310\n submit_one_bio+0x7f/0xb0\n submit_extent_page+0xc4/0x440\n __extent_writepage_io+0x2b8/0x5e0\n __extent_writepage+0x28d/0x6e0\n extent_write_cache_pages+0x4d7/0x7a0\n extent_writepages+0xa2/0x110\n do_writepages+0x8f/0x180\n __writeback_single_inode+0x99/0x7f0\n writeback_sb_inodes+0x34e/0x790\n __writeback_inodes_wb+0x9e/0x120\n wb_writeback+0x4d2/0x660\n wb_workfn+0x64d/0xa10\n process_one_work+0x53a/0xa80\n worker_thread+0x69/0x5b0\n kthread+0x20b/0x240\n ret_from_fork+0x1f/0x30\n\nOnly Kyber uses the hctx, so fix it by passing the request_queue to\n->bio_merge() instead. BFQ and mq-deadline just use that, and Kyber can\nmap the queues itself to avoid the mismatch.",
            "data": {
                "packageName": "linux",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2021-46984",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2021-47015",
            "similarityId": "CVE-2021-47015",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbnxt_en: Fix RX consumer index logic in the error path.\n\nIn bnxt_rx_pkt(), the RX buffers are expected to complete in order.\nIf the RX consumer index indicates an out of order buffer completion,\nit means we are hitting a hardware bug and the driver will abort all\nremaining RX packets and reset the RX ring.  The RX consumer index\nthat we pass to bnxt_discard_rx() is not correct.  We should be\npassing the current index (tmp_raw_cons) instead of the old index\n(raw_cons).  This bug can cause us to be at the wrong index when\ntrying to abort the next RX packet.  It can crash like this:\n\n #0 [ffff9bbcdf5c39a8] machine_kexec at ffffffff9b05e007\n #1 [ffff9bbcdf5c3a00] __crash_kexec at ffffffff9b111232\n #2 [ffff9bbcdf5c3ad0] panic at ffffffff9b07d61e\n #3 [ffff9bbcdf5c3b50] oops_end at ffffffff9b030978\n #4 [ffff9bbcdf5c3b78] no_context at ffffffff9b06aaf0\n #5 [ffff9bbcdf5c3bd8] __bad_area_nosemaphore at ffffffff9b06ae2e\n #6 [ffff9bbcdf5c3c28] bad_area_nosemaphore at ffffffff9b06af24\n #7 [ffff9bbcdf5c3c38] __do_page_fault at ffffffff9b06b67e\n #8 [ffff9bbcdf5c3cb0] do_page_fault at ffffffff9b06bb12\n #9 [ffff9bbcdf5c3ce0] page_fault at ffffffff9bc015c5\n    [exception RIP: bnxt_rx_pkt+237]\n    RIP: ffffffffc0259cdd  RSP: ffff9bbcdf5c3d98  RFLAGS: 00010213\n    RAX: 000000005dd8097f  RBX: ffff9ba4cb11b7e0  RCX: ffffa923cf6e9000\n    RDX: 0000000000000fff  RSI: 0000000000000627  RDI: 0000000000001000\n    RBP: ffff9bbcdf5c3e60   R8: 0000000000420003   R9: 000000000000020d\n    R10: ffffa923cf6ec138  R11: ffff9bbcdf5c3e83  R12: ffff9ba4d6f928c0\n    R13: ffff9ba4cac28080  R14: ffff9ba4cb11b7f0  R15: ffff9ba4d5a30000\n    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018",
            "data": {
                "packageName": "linux",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2021-47015",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2021-47015",
            "similarityId": "CVE-2021-47015",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbnxt_en: Fix RX consumer index logic in the error path.\n\nIn bnxt_rx_pkt(), the RX buffers are expected to complete in order.\nIf the RX consumer index indicates an out of order buffer completion,\nit means we are hitting a hardware bug and the driver will abort all\nremaining RX packets and reset the RX ring.  The RX consumer index\nthat we pass to bnxt_discard_rx() is not correct.  We should be\npassing the current index (tmp_raw_cons) instead of the old index\n(raw_cons).  This bug can cause us to be at the wrong index when\ntrying to abort the next RX packet.  It can crash like this:\n\n #0 [ffff9bbcdf5c39a8] machine_kexec at ffffffff9b05e007\n #1 [ffff9bbcdf5c3a00] __crash_kexec at ffffffff9b111232\n #2 [ffff9bbcdf5c3ad0] panic at ffffffff9b07d61e\n #3 [ffff9bbcdf5c3b50] oops_end at ffffffff9b030978\n #4 [ffff9bbcdf5c3b78] no_context at ffffffff9b06aaf0\n #5 [ffff9bbcdf5c3bd8] __bad_area_nosemaphore at ffffffff9b06ae2e\n #6 [ffff9bbcdf5c3c28] bad_area_nosemaphore at ffffffff9b06af24\n #7 [ffff9bbcdf5c3c38] __do_page_fault at ffffffff9b06b67e\n #8 [ffff9bbcdf5c3cb0] do_page_fault at ffffffff9b06bb12\n #9 [ffff9bbcdf5c3ce0] page_fault at ffffffff9bc015c5\n    [exception RIP: bnxt_rx_pkt+237]\n    RIP: ffffffffc0259cdd  RSP: ffff9bbcdf5c3d98  RFLAGS: 00010213\n    RAX: 000000005dd8097f  RBX: ffff9ba4cb11b7e0  RCX: ffffa923cf6e9000\n    RDX: 0000000000000fff  RSI: 0000000000000627  RDI: 0000000000001000\n    RBP: ffff9bbcdf5c3e60   R8: 0000000000420003   R9: 000000000000020d\n    R10: ffffa923cf6ec138  R11: ffff9bbcdf5c3e83  R12: ffff9ba4d6f928c0\n    R13: ffff9ba4cac28080  R14: ffff9ba4cb11b7f0  R15: ffff9ba4d5a30000\n    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018",
            "data": {
                "packageName": "linux-libc-dev",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2021-47015",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2021-47024",
            "similarityId": "CVE-2021-47024",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvsock/virtio: free queued packets when closing socket\n\nAs reported by syzbot [1], there is a memory leak while closing the\nsocket. We partially solved this issue with commit ac03046ece2b\n(\"vsock/virtio: free packets during the socket release\"), but we\nforgot to drain the RX queue when the socket is definitely closed by\nthe scheduled work.\n\nTo avoid future issues, let's use the new virtio_transport_remove_sock()\nto drain the RX queue before removing the socket from the af_vsock lists\ncalling vsock_remove_sock().\n\n[1] https://syzkaller.appspot.com/bug?extid=24452624fc4c571eedd9",
            "data": {
                "packageName": "linux-libc-dev",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2021-47024",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2021-47024",
            "similarityId": "CVE-2021-47024",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nvsock/virtio: free queued packets when closing socket\n\nAs reported by syzbot [1], there is a memory leak while closing the\nsocket. We partially solved this issue with commit ac03046ece2b\n(\"vsock/virtio: free packets during the socket release\"), but we\nforgot to drain the RX queue when the socket is definitely closed by\nthe scheduled work.\n\nTo avoid future issues, let's use the new virtio_transport_remove_sock()\nto drain the RX queue before removing the socket from the af_vsock lists\ncalling vsock_remove_sock().\n\n[1] https://syzkaller.appspot.com/bug?extid=24452624fc4c571eedd9",
            "data": {
                "packageName": "linux",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2021-47024",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2021-47049",
            "similarityId": "CVE-2021-47049",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nDrivers: hv: vmbus: Use after free in __vmbus_open()\n\nThe \"open_info\" variable is added to the &vmbus_connection.chn_msg_list,\nbut the error handling frees \"open_info\" without removing it from the\nlist.  This will result in a use after free.  First remove it from the\nlist, and then free it.",
            "data": {
                "packageName": "linux-libc-dev",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2021-47049",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2021-47049",
            "similarityId": "CVE-2021-47049",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nDrivers: hv: vmbus: Use after free in __vmbus_open()\n\nThe \"open_info\" variable is added to the &vmbus_connection.chn_msg_list,\nbut the error handling frees \"open_info\" without removing it from the\nlist.  This will result in a use after free.  First remove it from the\nlist, and then free it.",
            "data": {
                "packageName": "linux",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2021-47049",
                "cweId": "",
                "cvss": null
            }
        },
        {
            "type": "containers",
            "id": "CVE-2021-47061",
            "similarityId": "CVE-2021-47061",
            "status": "NEW",
            "state": "TO_VERIFY",
            "severity": "INFO",
            "confidenceLevel": 0,
            "created": "2024-11-14T06:23:06Z",
            "firstFoundAt": "2024-11-14T06:22:50Z",
            "foundAt": "2024-11-14T06:23:06Z",
            "firstScanId": "83b23bdf-7510-4424-b6dc-feb092e775b7",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: Destroy I/O bus devices on unregister failure _after_ sync'ing SRCU\n\nIf allocating a new instance of an I/O bus fails when unregistering a\ndevice, wait to destroy the device until after all readers are guaranteed\nto see the new null bus.  Destroying devices before the bus is nullified\ncould lead to use-after-free since readers expect the devices on their\nreference of the bus to remain valid.",
            "data": {
                "packageName": "linux-libc-dev",
                "packageVersion": "4.19.304-1",
                "imageName": "library/node",
                "imageTag": "20-buster",
                "imageFilePath": "Dockerfile",
                "imageOrigin": "Dockerfile"
            },
            "comments": {
                "comments": ""
            },
            "vulnerabilityDetails": {
                "cvssScore": 0,
                "cveName": "CVE-2021-47061",
                "cweId": "",
                "cvss": null
            }
        }
    ],
    "totalCount": 3613
}